## Compiler Optimization

### 为什么需要优化

1. 代码效率低下，我们不能保证所有程序员都写出效率最高的代码，并且有些效率高的代码会降低可读性
2. 充分利用硬件资源
3. 下面说的编译器对逻辑的优化只针对于编译型语言，如果是脚本型语言如 python，我们就需要注意自己的代码逻辑了，因为没有编译器帮我们优化

### 优化技巧（参考自 IBM 官网）

1. 带优化的编译
2. 针对特定硬件平台的编译
3. 针对浮点性能的编译
4. 指定高速缓存大小
5. 扩展内联过程调用
6. 何时使用动态链接和静态链接
7. 预装入共享库
8. 指定链接顺序来减少大程序的页面调度
9. 调用 BLAS 和 ESSL 库
10. fdpr 命令

---

### 这里，我们就只介绍带优化的编译，就是编译器对代码逻辑的优化(其他的我也不懂啊~~)

编译器都带有优化功能，例如 C 和 C++ 的编译器 gcc 有 O1，O2 和 O3 等级别的优化，优化会改变代码结构，降低可读性，难以调试，因此在调试时还是关闭优化，编译器的优化使我们的代码在保留可读性的同时又可以提高性能，这里介绍一些比较简单的优化。

- 分支 (if-then-else):

    **优化前提: cpu 的分支预测: 当 CPU 遇到跳转指令的时候，为了提高效率，会做一个预测，把预测的分支代码载入流水线，当发现预测错误的时候，需要清空流水线，重新载入正确的分支到流水线，详细怎么发现错误没了解。**

    1. 合并分支: (a0==0) && (a1==0) && (a2==0) -> (a0|a1|a2)==0，提高预测的成功率
    2. 使用条件状态值生成掩码来移除条件分支: if (color<0) color=0 -> color &=-(color>=0)
    3. 查表法移除分支: 用一个 map 映射来替换原来的条件判断
    4. 使用条件传送指令: 编译到汇编时用 cmov 指令判断而不是通过 jmp 跳转代码块

- 循环 (loop):

    1. 将常量表达式从循环中移除: 减少无意义的赋值

        ```
        # 优化前
        while(x) {
            i = 1;
            a += i;
        }

        # 优化后
        i = 1;
        while(x) {
            a += i;
        }
        ```

    2. 循环展开: 减少判断次数

        ```
        # 优化前
        for (int i = 0; i < 1024; i++) {
            array[i] *= 2;
        }

        # 优化后
        for (int i = 0; i < 1024; i+=4) {
            array[i] *= 2;
            array[i+1] *= 2;
            array[i+2] *= 2;
            array[i+3] *= 2;
        }
        ```

    3. Software pipelining: 充分利用 cpu 流水线

        ```
        # 优化前
        for (int i = 0; i < 1024; i++) {
            func_A(i)
            func_B(i)
            func_C(i)
        }
        ```

        - 这里的执行顺序是 A(i), B(i), C(i), A(i+1), B(i+1), C(i+1), ....
        - 由于A(i), B(i), C(i)都依赖于i因此 B(i) 和 C(i) 都要等待 A(i) 完成，后面的循环也一样
        
        ```
        # 优化后
        for (int i = 0; i < 1020; i+=4) {
            func_A(i)
            func_A(i+1)
            func_A(i+2)
            func_A(i+3)
            func_B(i)
            func_B(i+1)
            func_B(i+2)
            func_B(i+3)
            func_C(i)
            func_C(i+1)
            func_C(i+2)
            func_C(i+3)
        }
        ```

        - 这样 A(i), A(i+1), A(i+2), A(i+3) 可以在多核同时运行了

    4. 强度折减: 用便宜的运算替代昂贵的运算，例如乘法换成加法

        ```
        # 优化前
        a = 8
        for (int i = 0; i < 1024; i++) {
            b += a * i;
        }

        # 优化后
        a = 8
        for (int i = 0; i < 1024; i++) {
            a += 8
            b += a;
        }
        ```

- 代码替换

    1. 用计算后的值替代常量表达式:

        ```
        # 优化前
        a = 8
        b = 9
        x = a * b

        # 优化后
        a = 8
        b = 9
        x = 72
        ```

    2. 合并相同的常量: 横跨编译单元合并同样的常量

    3. 内联函数: 把实际的程序代码代替函数调用，减少栈和跳转操作

    4. 无效代码的消除: 消除哪些没有用到的或其结果在后面的运行中没有用到的代码

    5. 尾递归优化: 用循环替换尾递归

---

### volatile 关键字

volatile 关键字用来阻止（伪）编译器认为的无法“被代码本身”改变的代码（变量/对象）进行优化，不过他在不同语言会有不同的效果

- C: volatile 关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

    ```
    static int foo;
    void bar(void) {
        foo = 0;
        while (foo != 255)
            ;
    }
    ```

    - 例如说上面这一段代码由于编译器认为程序中的 foo 永远不可能变成 255，因此会进行优化

    ```
    static int foo;
    void bar(void) {
        foo = 0;
        while (true)
            ;
    }
    ```

    - 那么当其他程序改变这个 foo 的值时，这个程序也无法发现

- Java: 读和写一个 volatile 变量有全局的排序。也就是说每个线程访问一个 volatile 作用域时会在继续执行之前读取它的当前值，而不是（可能）使用一个缓存的值。(但是并不保证经常读写 volatile 作用域时读和写的相对顺序，也就是说通常这并不是有用的线程构建)。